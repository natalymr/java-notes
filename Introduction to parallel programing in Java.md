## Введение

Пакеты:
* java.lang
* java.util.concurrent

**Thread** - класс, который позволяет  создавать  потоки  и  производить  операции  с  ними

**Runnable** - интерфейс, который представляет собой сущность,
которая может быть запущена, имеет метод
`public void run()`

Создание и запуск потока:
```java
//  Создание  потока
Thread  t  =  new  Thread(new  Runnable()  {
    public  void  run()  {
        System.out.println("Hello");
    }
});

//  Запуск  потока
t.start();
```

Примеры инстанцирования потока:
* Если  вы  расширили  класс  Thread:
```java
MyThread  t  =  new  MyThread();
```

* Если  вы  реализовывали  Runnable:

```java
MyRunnable  r  =  new  MyRunnable();
Thread  t  =  new  Thread(r);
```
* Один  экземпляр  Runnable  можно  передать  нескольким  объектам  Thread:
```java
MyRunnable  r  =  new  MyRunnable();

Thread  foo  =  new  Thread(r);
Thread  bar  =  new  Thread(r);
Thread  bat  =  new  Thread(r);
```

Запуск потока:
```java
t.start();
```


Свойства потока (не могут быть изменены после того, как поток был запущен):
* id - идентификатор потока
* name - имя потока
* priority - приоритет
* daemon - поток-демон

....

_пропустила несколько слайдов_

----

### Мониторы и условия

_Что такое монитор?_ [Источник №1](http://pro-java.ru/other/koncepciya-monitora/)

В терминологии Java монитор обладает перечисленными ниже свойствами.
* **Монитор** - это класс, имеющий только приватные поля.
* Каждый объект этого класса имеет ассоциированную с ним блокировку.
* Все методы блокируются этой блокировкой. Другими словами,
если клиент вызывает **obj.method()**, то при этом автоматически
запирается блокировка объекта **obj** в начале метода и освобождается
по его завершении. Поскольку все поля приватные, такой подход
гарантирует, что ни один поток не сможет обратиться к ним, пока
ими манипулирует какой-то другой поток.
* Блокировка может иметь любое количество ассоциированных условий.

Проектировщики Java вольно адаптировали концепцию монитора.
 Каждый объект в Java обладает внутренной блокировкой и внутренним условием.
 Если метод объявлен с ключевым словом **synchronized**, он работает как метод монитора.
 Переменная условия доступна через вызовы **wait/notifyAll/notify**.

 Однако объекты Java отличаются от мониторов в трех важных отношениях,
 ослабляющих безопасность потоков.

 * Поля не обязательно должны быть **private**.
 *  Методы не обязаны быть **synchronized**.
 * Внутренняя блокировка доступна клиентам.

_Что такое монитор?_ [Википедия](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B8%D1%82%D0%BE%D1%80_(%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F))


**Монитор** - это высокоуровневый механизм взаимодействия и синхронизации процессов,
 обеспечивающий доступ к неразделяемым ресурсам.
 Подход к синхронизации двух или более компьютерных задач,
 использующих общий ресурс, обычно набор переменных.

Монитор состоит из:
* набора процедур, взаимодействующих с общим ресурсом
* мьютекса
* переменных, связанных с этим ресурсом
* инварианта, который определяет условия, позволяющие избежать состояние гонки

> **Мьютекс** - «взаимное исключение» - аналог одноместного семафора,
служащий в программировании для синхронизации одновременно выполняющихся потоков.
>> **Семафор** - объект, ограничивающий количество потоков,
которые могут войти в заданный участок кода.
Семафоры используются для синхронизации и защиты передачи
данных через разделяемую память, а также для синхронизации работы процессов и потоков.
>>
>>
>>Семафор — это объект, над которым можно выполнить три операции.
>> * Инициализация семафора, `init()` - задать начальное значение счётчика
>> * Захват семафора, `enter()` - ждать пока счётчик станет больше 0,
после этого уменьшить счётчик на единицу
>> * Освобождение семафора, `leave()` - увеличить счётчик на единицу
>>
>>
>>Некоторые из проблем, которые могут решать семафоры:
>> * запрет одновременного выполнения заданных участков кода (критические секции)
>> * поочерёдный доступ к критическому ресурсу
(важному ресурсу, для которого невозможен (или нежелателен) одновременный доступ)
>> * синхронизация процессов и потоков
(например, можно инициировать обработку события отпусканием семафора)
>>
> Мьютекс отличается от семафора тем, что только владеющий
им поток может его освободить, т.е. перевести в отмеченное состояние.
>
> Задача мьютекса — защита объекта от доступа к нему других потоков,
отличных от того, который завладел мьютексом.

Процедура монитора захватывает мьютекс перед началом работы
и держит его или до выхода из процедуры, или до момента ожидания условия
(см. ниже). Если каждая процедура гарантирует, что перед освобождением
мьютекса инвариант истинен, то никакая задача не может получить ресурс
в состоянии, ведущем к гонке.

Пример монитора, выполняющего транзакции банковского счета:
```
monitor account {
  int balance := 0

  //  функция снятия со счета
  function withdraw(int amount) {
    if amount < 0 then error "Счёт не может быть отрицательным"
    else if balance < amount then error "Недостаток средств"
    else balance := balance - amount
  }

  //  функция пополнения счета
  function deposit(int amount) {
    if amount < 0 then error "Сумма не может быть отрицательной"
    else balance := balance + amount
  }
}
```
Блокировка добавлена компилятором.
Это делает мониторы безопаснее и удобнее, чем другие подходы,
требующие от программиста вручную добавлять операции
блокировки-разблокировки, — поскольку программист может забыть добавить их.

**Условные переменные**

Чтобы избегать состояния активного ожидания, процессы
должны сигнализировать друг другу об ожидаемых событиях.
Мониторы обеспечивают эту возможность с помощью условных переменных.

Когда процедура монитора требует для дальнейшей работы выполнения
определённого условия, она ждёт связанную с ним условную переменную.
 Во время ожидания она временно отпускает мьютекс и выбывает
 из списка исполняющихся процессов.

 Любой процесс, который в дальнейшем приводит к выполнению этого условия,
 использует условную переменную для оповещения ждущего её процесса.
  Оповещённый процесс захватывает мьютекс обратно и может продолжать.


---

В классе `Object` есть три метода: `wait()`, `notify()`, `notifyAll()`, которые
позволяют потоку сообщать информацию о своем состоянии другим, заинтересованным
в этой информации, потокам.

* **wait()** - заставляет текущий поток ждать, пока другой поток не вызовет метод
 `notify()` или `notifyAll()` для этого объекта. Текущий поток должен владеть
 монитором этого объекта. Возможны прерывания и ложные пробуждения,
 поэтому этот метод должен быть всегда использован в цикле:
    ```java
    synchronized (obj) {
         while (<condition does not hold>)
             obj.wait();
         ... // Perform action appropriate to condition
    }
    ```
 * **notify()** - пробуждает один поток, который ждет на мониторе этого объекта.
 Если потоков несколько, будет выбран произвольный. Оповещенный поток не имеет
 привилегий на владения объектом и есть вероятность появления гонки за ресурс.
 Этот ментод долэен вызываться только тем потоком, который являетсв владельцем монитора
 этого объекта.

 * **notifyAll()** - пробуждает все потоки, которые ждут на мониторе этого объекта.

> Замечания:
> * При  ожидании  монитора, **wait()**,  блокировка  с  него  снимается
> * При  извещении  поток  не  получает  управления  пока  не  может
получить  блокировку  обратно
> * **notify()**  и  **notifyAll()**  не  снимают  блокировку!

 Пример №1 "Производитель-Потребитель":
 ```java
//  Производитель
public  synchronized  void  set(Object  data)  throws  InterruptedException  {
    if (this.data !=  null)  {
        wait();//  Пассивное  ожидание
    }

    this.data =  data;
    notify();
}


//  Потребитель
public  synchronized  Object  get()  throws  InterruptedException  {
    if  (data  ==  null)  {
        wait();//  Пассивное  ожидание
    }

    Object  d  =  data;
    data  =  null;
    notify();
    return  d;
}
 ```


